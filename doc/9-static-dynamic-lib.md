# 静态库和动态库

- [静态库和动态库](#静态库和动态库)
  - [概述](#概述)
  - [使用源码](#使用源码)
  - [使用 C 静态库](#使用-c-静态库)
    - [使用 gcc 命令编译本地源码生成静态库](#使用-gcc-命令编译本地源码生成静态库)
    - [使用 go tool 编译本地源码生成静态库](#使用-go-tool-编译本地源码生成静态库)
    - [使用第三方静态库](#使用第三方静态库)
      - [pkg-config 指定库的安装路径](#pkg-config-指定库的安装路径)
  - [使用 C 动态库](#使用-c-动态库)
  - [导出 C 静态库](#导出-c-静态库)
  - [导出 C 动态库](#导出-c-动态库)
  - [导出非 main 包的函数](#导出非-main-包的函数)

## 概述

cgo 使用 C/C++ 资源一般有三种形式：

- 直接使用源码：在 `import "C"` 之前的注释部分包含 C 代码，或在当前包中包含 C/C++ 源文件
- 链接静态库：在 `LDFLAGS` 指定链接静态库
- 链接动态库：在 `LDFLAGS` 指定链接动态库

## 使用源码

如果有 C/C++ 源码，且代码规模比较小，建议直接使用源码。但是很多时候并没有源代码，或者从 C/C++ 源代码开始构建的过程比较复杂，此时可以使用静态库或动态库。

```h
// number.h
int number_add_mod(int a, int b, int mod);
```

```c
// number.c
#include "number.h"

int number_add_mod(int a, int b, int mod) {
  return (a+b)%mod;
}
```

## 使用 C 静态库

静态库是静态链接，最终的目标程序不会产生额外的运行时依赖，也不会出现动态库特有的跨运行时资源管理的错误。

但是静态库对链接阶段有一定的要求：静态库一般包含了全部的代码，里面有大量的符号，如果不同静态库之间出现符号冲突会导致链接失败。

cgo 使用的是 gcc 命令编译和链接 C 和 go 桥接的代码，因此静态库必须是 gcc 兼容的格式。

```go
// main.go
package main

/*
#cgo CFLAGS: -I./number
#cgo LDFLAGS: -L${SRCDIR}/number -lnumber

#include "number.h"
*/
import "C"
import "fmt"

func main() {
  fmt.Println(int(C.number_add_mod(5, 10, 4)))
}
```

### 使用 gcc 命令编译本地源码生成静态库

```sh
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/1/number cd ./number
# 得到 *.o 文件
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/1/number gcc -c -o number.o number.c
# 将所有 .o 文件打包为静态库: r 将文件插入静态库中;c 创建静态库，不管库是否存在;s 写入一个目标文件索引到库中，或者更新一个存在的目标文件索引
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/1/number ar rcs libnumber.a number.o
# 也可以直接编译静态库
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/1/number gcc -c -o libnumber.a number.c
# 查看库中包含的函数等信息
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/1/number nm libnumber.a
0000000000000000 T number_add_mod
```

### 使用 go tool 编译本地源码生成静态库

### 使用第三方静态库

如果使用的是第三方静态库，需要先下载安装静态库到合适的位置。然后在 `#cgo` 命令通过 `CFLAGS` 和 `LDFLAGS` 指定头文件和库的位置。

#### pkg-config 指定库的安装路径

对于不同的操作系统甚至同一组操作系统的不同版本，这些库的安装路径可能不同，可以使用 `pkg-config` 命令在代码中指定这些可能变化的参数。

在 Linux 环境中，`pkg-config` 命令可以查询要使用某个静态库或动态库时的编译和链接参数。可以在 `#cgo` 中直接使用 `pkg-config` 命令来生成编译和链接参数。还可以通过 `PKG_CONFIG` 环境变量定制 `pkg-config` 命令。

相关文档[参考](https://github.com/xueqing/MyNote/blob/master/ubuntu_study/ubuntu_pkgconfig.md)。

## 使用 C 动态库

在 Linux 环境下，可以用 gcc 命令创建动态库：

```sh
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/2/number gcc -shared -o libnumber.so number.c
```

动态库和静态库的基础名称相同，只是后缀名不同，因此 go 语言部分使用静态库和动态库的代码相同。

编译时 gcc 会自动找到 `libnumber.a` 或 `libnumber.so` 进行链接。

**注意**：运行时需要将动态库放在系统可以找到的位置。Linux 下需要设置 `LD_LIBRARY_PATH` 环境变量，否则会报下面的错误。

```txt
/tmp/go-build306938573/b001/exe/main: error while loading shared libraries: libnumber.so: cannot open shared object file: No such file or directory
exit status 127
```

## 导出 C 静态库

cgo 不仅可以使用 C 静态库，也可以将 go 实现的函数导出为 c 静态库。下面用 go 实现上面的函数。

```go
// number.go
package main

import "C"

func main() {}

//export number_add_mod
func number_add_mod(a, b, mod C.int) C.int {
  return (a + b) % mod
}
```

根据 cgo 文档的要求，需要在 `main` 包中国导出 C 函数，对于 C 静态库构建方式，会忽略 `main` 包中的 `main` 函数，只是导出 C 函数。构建命令如下：

```sh
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/2/number go build -buildmode=c-archive -o number.a
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/2/number ls
number.a  number.go  number.h
```

在生成 `number.a` 静态库的同时，cgo 还会生成一个 `number.h` 文件。内容如下：

```h
// number.h
/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package github.com/xueqing/cgo-study/src/9-static-dynamic-lib/3/number */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h> /* for ptrdiff_t below */

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
#endif

... ...

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


extern int number_add_mod(int p0, int p1, int p2);

#ifdef __cplusplus
}
#endif
```

其中，`extern "C"` 语法是为了适配 C 和 C++。最后几行声明要导出 `number_add_mod` 函数。

```c
// test_number.c
#include <stdio.h>

#include "number.h"

int main() {
  // go build -buildmode=c-archive -o number.a
  // gcc test_number.c number.a -lpthread
  int a=10, b=4, mod=5;

  printf("(%d+%d)%%%d = %d\n", a, b, mod, number_add_mod(a,b,mod));

  return 0;
}
```

测试生成的静态库：

```sh
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/3/number$ gcc test_number.c number.a -lpthread
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/3/number$ ./a.out
(10+4)%5 = 4
```

## 导出 C 动态库

源码和上面的相同，只需要修改构建模式和输出文件名：

```sh
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/4/number go build -buildmode=c-shared -o number.so
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/4/number ls
number.go  number.h  number.so
```

测试文件 `test_number.c` 源码同上，测试生成的动态库：

```sh
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/4/number$ gcc test_number.c number.so
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/4/number$ ./a.out
(10+4)%5 = 4
```

## 导出非 main 包的函数

通过 `go help buildmode` 查看构建说明：

```txt
The 'go build' and 'go install' commands take a -buildmode argument which
indicates which kind of object file is to be built. Currently supported values
are:

  -buildmode=archive
    Build the listed non-main packages into .a files. Packages named
    main are ignored.

  -buildmode=c-archive
    Build the listed main package, plus all packages it imports,
    into a C archive file. The only callable symbols will be those
    functions exported using a cgo //export comment. Requires
    exactly one main package to be listed.

  -buildmode=c-shared
    Build the listed main package, plus all packages it imports,
    into a C shared library. The only callable symbols will
    be those functions exported using a cgo //export comment.
    Requires exactly one main package to be listed.

  -buildmode=default
    Listed main packages are built into executables and listed
    non-main packages are built into .a files (the default
    behavior).

  -buildmode=shared
    Combine all the listed non-main packages into a single shared
    library that will be used when building with the -linkshared
    option. Packages named main are ignored.

  -buildmode=exe
    Build the listed main packages and everything they import into
    executables. Packages not named main are ignored.

  -buildmode=pie
    Build the listed main packages and everything they import into
    position independent executables (PIE). Packages not named
    main are ignored.

  -buildmode=plugin
    Build the listed main packages, plus all packages that they
    import, into a Go plugin. Packages not named main are ignored.

On AIX, when linking a C program that uses a Go archive built with
-buildmode=c-archive, you must pass -Wl,-bnoobjreorder to the C compiler.
```

文档说明导出 C 库必须是在 `main` 包。要实现从非 `main` 包导出 C 函数，或者多个包导出 C 函数，需要自己提供导出 C 函数对应的头文件(cgo 无法为非 `main` 包的导出函数生成头文件)。

假如 `number.go` 是一个子包，只修改包名：

```go
// number.go
package number

import "C"

//export number_add_mod
func number_add_mod(a, b, mod C.int) C.int {
  return (a + b) % mod
}
```

然后是 `main` 包。其中导入了上面的子包，并在 `main` 包添加一个导出函数：

```go
package main

import "C"

import (
  "fmt"

  _ "github.com/xueqing/cgo-study/src/9-static-dynamic-lib/5/number"
)

func main() {
  fmt.Println("Done")
}

//export goPrintln
func goPrintln(s *C.char) {
  fmt.Println("goPrintln:", C.GoString(s))
}
```

通过下面的命令创建 C 静态库：

```sh
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/5$ go build -buildmode=c-archive -o main.a
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/5$ ls
main.a  main.go  main.h  number
```

生成 `main.a` 静态库的同时，也会生成一个 `main.h` 头文件，但是其中并没有子包导出函数的声明。其实子包的导出函数存在生成的静态库，可以直接使用。

```sh
# 查看子包导出函数的符号
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/5$ nm main.a | grep number_add_mod
000000000008d1d0 T _cgoexp_312f1826d673_number_add_mod
000000000008d230 t github.com/xueqing/cgo-study/src/9-static-dynamic-lib/5/number._cgoexpwrap_312f1826d673_number_add_mod
                 U _cgoexp_312f1826d673_number_add_mod
0000000000000000 T number_add_mod
# 查看 main 包导出函数的符号
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/5$ nm main.a | grep goPrintln
000000000008d270 T _cgoexp_1d9f785ec154_goPrintln
000000000008d2d0 t main._cgoexpwrap_1d9f785ec154_goPrintln
000000000008d3a0 t main.goPrintln
000000000004db20 d main.goPrintln.stkobj
                 U _cgoexp_1d9f785ec154_goPrintln
0000000000000000 T goPrintln
```

测试 `main.a` 导出的 C 函数：

```c
// test_main.c
#include <stdio.h>

void goPrintln(char*);
int number_add_mod(int a, int b, int mode);

int main() {
  // go build -buildmode=c-shared -o number.so
  // gcc test_number.c number.so
  int a=10, b=4, mod=5;

  printf("(%d+%d)%%%d = %d\n", a, b, mod, number_add_mod(a,b,mod));

  goPrintln("hi, test main");

  return 0;
}
```

**注意**：可以不用包含导出的头文件，而是通过手动方式声明两个导出函数。这样就实现了从多个 go 包导出 C 函数。

```sh
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/5$ gcc test_main.c main.a -lpthread
kiki@ubuntu:~/github/cgo-study/src/9-static-dynamic-lib/5$ ./a.out
(10+4)%5 = 4
goPrintln: hi, test main
```
